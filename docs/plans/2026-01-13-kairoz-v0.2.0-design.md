# Kairoz v0.2.0 Design

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:writing-plans to create the implementation plan from this design.

**Goal:** Expand natural language parsing with backward offsets, period semantics, boundary expressions, and richer return types that preserve user intent.

**Key insight:** Existing date parsers lose semantic information. "next month" means *the month*, not a specific date. Kairoz v0.2.0 distinguishes periods from specific dates.

---

## Core Types

### Granularity

```zig
pub const Granularity = enum {
    day,
    week,
    month,
    year,
};
```

### Period

```zig
pub const Period = struct {
    start: Date,
    granularity: Granularity,

    /// Compute the last day of this period
    pub fn end(self: Period) Date {
        return switch (self.granularity) {
            .day => self.start,
            .week => addDays(self.start, 6),
            .month => lastDayOfMonth(self.start),
            .year => Date.initUnchecked(self.start.year, 12, 31),
        };
    }
};
```

### ParsedDate (updated)

```zig
pub const ParsedDate = union(enum) {
    /// Specific date: "tomorrow", "+3d", "2024-06-15", "end of month"
    date: Date,

    /// Period reference: "next week", "next month", "february"
    period: Period,

    /// Clear intent: "none", "clear"
    clear,
};
```

---

## Parsing Rules

### Existing (v0.1.0) — unchanged

| Expression | Result | Notes |
|------------|--------|-------|
| `today` | `.date` | Reference date |
| `tomorrow` | `.date` | +1 day |
| `yesterday` | `.date` | -1 day |
| `monday`, `mon` | `.date` | Next occurrence (1-7 days) |
| `+3d`, `+2w`, `+1m` | `.date` | Forward offset |
| `2024-06-15` | `.date` | Absolute YYYY-MM-DD |
| `06-15` | `.date` | MM-DD (current year) |
| `15` | `.date` | Day (current month) |
| `none`, `clear` | `.clear` | Clear intent |

### New — Backward offsets

| Expression | Result | Notes |
|------------|--------|-------|
| `-3d`, `-2w`, `-1m`, `-1y` | `.date` | Backward arithmetic |

### New — Year offset

| Expression | Result | Notes |
|------------|--------|-------|
| `+1y`, `+2y` | `.date` | Forward year arithmetic |

### New — Weekday modifiers

| Expression | Result | Notes |
|------------|--------|-------|
| `next monday` | `.date` | Skip to following week's Monday |
| `last monday` | `.date` | Most recent past Monday |

### New — Period references

| Expression | Result | Notes |
|------------|--------|-------|
| `next week` | `.period { next Mon, .week }` | Start of next week |
| `last week` | `.period { prev Mon, .week }` | Start of previous week |
| `this week` | `.period { this Mon, .week }` | Start of current week |
| `next month` | `.period { 1st of next month, .month }` | |
| `last month` | `.period { 1st of prev month, .month }` | |
| `this month` | `.period { 1st of current month, .month }` | |
| `next year` | `.period { Jan 1 next year, .year }` | |
| `last year` | `.period { Jan 1 prev year, .year }` | |
| `this year` | `.period { Jan 1 current year, .year }` | |

### New — Month/year names as periods

| Expression | Result | Notes |
|------------|--------|-------|
| `february`, `feb` | `.period { Feb 1, .month }` | Current or next occurrence |
| `2024` | `.period { Jan 1 2024, .year }` | Year alone |

### New — Natural offsets

| Expression | Result | Notes |
|------------|--------|-------|
| `in 3 days` | `.date` | Same as `+3d` |
| `in 2 weeks` | `.date` | Same as `+2w` |
| `in 1 month` | `.date` | Same as `+1m` |
| `in 1 year` | `.date` | Same as `+1y` |
| `3 days ago` | `.date` | Same as `-3d` |
| `2 weeks ago` | `.date` | Same as `-2w` |
| `1 month ago` | `.date` | Same as `-1m` |
| `1 year ago` | `.date` | Same as `-1y` |

### New — Boundary expressions

| Expression | Result | Notes |
|------------|--------|-------|
| `end of month` | `.date` | Last day of current month |
| `end of week` | `.date` | Sunday of current week |
| `end of year` | `.date` | Dec 31 of current year |
| `beginning of month` | `.date` | 1st of current month |
| `beginning of week` | `.date` | Monday of current week |
| `beginning of year` | `.date` | Jan 1 of current year |
| `end of next month` | `.date` | Last day of next month |
| `end of next week` | `.date` | Sunday of next week |
| `beginning of next month` | `.date` | 1st of next month |
| `beginning of next week` | `.date` | Monday of next week |
| `end of last month` | `.date` | Last day of previous month |
| `beginning of last month` | `.date` | 1st of previous month |

### New — Ordinal days

| Expression | Result | Notes |
|------------|--------|-------|
| `1st`, `2nd`, `3rd`, `23rd` | `.date` | Day of current month |

---

## Error Handling

### Error types (unchanged)

```zig
pub const ParseError = error{
    InvalidFormat,   // Unrecognized expression
    InvalidOffset,   // +0d, -0w (zero offset)
};

pub const DateError = error{
    InvalidDay,
    InvalidMonth,
    InvalidYear,
};

pub const ArithmeticError = error{
    YearOutOfRange,  // Result year < 1 or > 65535
};
```

### Edge cases

| Scenario | Behavior |
|----------|----------|
| `+0d`, `-0w` | `InvalidOffset` (zero makes no sense) |
| `-1y` from year 1 | `YearOutOfRange` |
| `end of month` on Jan 31 | Jan 31 (current month) |
| `last monday` on a Monday | Previous Monday (-7 days) |
| `next monday` on a Monday | Following Monday (+7 days) |
| `february` in January | `.period { Feb 1 current year, .month }` |
| `february` in March | `.period { Feb 1 next year, .month }` |
| `january` in January | `.period { Jan 1 next year, .month }` (skip current) |
| `2024` (bare year) | `.period { Jan 1 2024, .year }` |
| `31st` in February | `InvalidDay` |

### Week boundaries

- Week starts **Monday** (ISO 8601)
- `end of week` = Sunday
- `beginning of week` = Monday

### Month name resolution

When parsing a month name like `february`:
- If current month < target month: this year
- If current month >= target month: next year
- Always returns a future or current period (never past)

---

## Implementation Architecture

### Parser order

Try patterns from most specific to least specific:

1. Trim & lowercase
2. Clear keywords: `none`, `clear`
3. Boundary expressions: `end of month`, `beginning of next week`
4. Period references: `next week`, `last month`, `this year`
5. Weekday with modifier: `next monday`, `last friday`
6. Natural offsets: `in 3 days`, `2 weeks ago`
7. Simple keywords: `today`, `tomorrow`, `yesterday`
8. Weekday names: `monday`, `fri`
9. Month names: `february`, `dec`
10. Offset syntax: `+3d`, `-2w`, `+1m`, `-1y`
11. Ordinal days: `1st`, `23rd`
12. Absolute dates: `2024-06-15`, `06-15`, `15`, `2024`
13. Return `InvalidFormat`

### File organization

```
src/
├── root.zig          # Public exports (add Granularity, Period)
├── Date.zig          # Unchanged
├── parse.zig         # Main parsing logic (major expansion)
├── arithmetic.zig    # Add year arithmetic and week/month helpers
└── format.zig        # Minor updates for period formatting
```

### New helpers in arithmetic.zig

```zig
pub fn lastDayOfMonth(date: Date) Date
pub fn firstDayOfMonth(date: Date) Date
pub fn startOfWeek(date: Date) Date      // Monday of date's week
pub fn endOfWeek(date: Date) Date        // Sunday of date's week
pub fn addYears(date: Date, years: i32) ArithmeticError!Date
```

---

## Testing Strategy

### Test categories

| Category | Focus |
|----------|-------|
| Backward offsets | `-3d`, `-2w`, `-1m`, `-1y` |
| Weekday modifiers | `next monday`, `last friday`, same-day edge cases |
| Period references | `next week`, `last month`, `this year` |
| Month names | `february` in Jan vs March, `january` in January |
| Natural offsets | `in 3 days`, `2 weeks ago`, `in 1 year` |
| Boundaries | `end of month`, `beginning of week`, `end of next month` |
| Ordinals | `1st`, `2nd`, `23rd`, `31st` in short month |
| Year expressions | `2024`, `next year`, `last year`, `+1y` |
| Period.end() | Week end = +6 days, month end, year end |
| Edge cases | Year boundaries, leap years, Monday-on-Monday |

### Test count estimate

~130 tests total (up from 53 in v0.1.0)

### Reference date

Continue using `2024-01-15` (Monday) as primary reference for week boundary testing.

---

## Breaking Changes from v0.1.0

1. `ParsedDate` union gains `.period` variant — existing switch statements become non-exhaustive
2. Callers must handle the new variant

Migration path: Update switches to handle `.period`, or use `period.start` when only a date is needed.

---

## Future Considerations (not in v0.2.0)

- Time support: `tomorrow 3pm`, `friday at 8pm`
- Date ranges: `Sep 12-13`, `Monday to Friday`
- Compound expressions: `3 days before next friday`
- Week numbers: `W24`, `week 24`
- Localization / i18n
- Configurable week start (Sunday vs Monday)
