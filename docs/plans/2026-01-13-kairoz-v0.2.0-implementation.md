# Kairoz v0.2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Expand Kairoz with period semantics, backward offsets, boundary expressions, and natural language patterns that preserve user intent.

**Architecture:** Add `Granularity` and `Period` types, expand `ParsedDate` union with `.period` variant. Parser tries patterns from most specific (multi-word) to least specific (single tokens). All date arithmetic flows through `arithmetic.zig`.

**Tech Stack:** Zig 0.16+, zero dependencies, TDD with `zig build test`

**Design doc:** `docs/plans/2026-01-13-kairoz-v0.2.0-design.md`

---

### Task 1: Add Granularity and Period types

**Files:**
- Modify: `src/root.zig`
- Modify: `src/parse.zig`

**Step 1: Add Granularity enum to parse.zig**

Add after line 22 (after `ParsedDate` definition will move):

```zig
pub const Granularity = enum {
    day,
    week,
    month,
    year,
};
```

**Step 2: Add Period struct to parse.zig**

```zig
pub const Period = struct {
    start: Date,
    granularity: Granularity,
};
```

**Step 3: Update ParsedDate to include period variant**

Change `ParsedDate` from:
```zig
pub const ParsedDate = union(enum) {
    date: Date,
    clear,
};
```

To:
```zig
pub const ParsedDate = union(enum) {
    date: Date,
    period: Period,
    clear,
};
```

**Step 4: Export new types from root.zig**

Add to `src/root.zig`:
```zig
pub const Granularity = @import("parse.zig").Granularity;
pub const Period = @import("parse.zig").Period;
```

**Step 5: Run tests to verify nothing broke**

Run: `zig build test`
Expected: All 53 existing tests pass

**Step 6: Commit**

```bash
git add src/root.zig src/parse.zig
git commit -m "feat: add Granularity and Period types to ParsedDate"
```

---

### Task 2: Add Period.end() method

**Files:**
- Modify: `src/parse.zig`
- Modify: `src/arithmetic.zig`

**Step 1: Write failing test for Period.end() with day granularity**

Add to `src/parse.zig` at end of file:

```zig
test "Period.end returns same day for day granularity" {
    const period = Period{
        .start = Date.initUnchecked(2024, 1, 15),
        .granularity = .day,
    };
    const end_date = period.end();
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), end_date);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL - no member named 'end' in 'Period'

**Step 3: Write failing test for week granularity**

```zig
test "Period.end returns Sunday for week granularity" {
    // Start on Monday Jan 15, 2024
    const period = Period{
        .start = Date.initUnchecked(2024, 1, 15),
        .granularity = .week,
    };
    const end_date = period.end();
    // End should be Sunday Jan 21, 2024 (+6 days)
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 21), end_date);
}
```

**Step 4: Write failing test for month granularity**

```zig
test "Period.end returns last day of month" {
    const period = Period{
        .start = Date.initUnchecked(2024, 2, 1),
        .granularity = .month,
    };
    const end_date = period.end();
    // Feb 2024 has 29 days (leap year)
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 29), end_date);
}
```

**Step 5: Write failing test for year granularity**

```zig
test "Period.end returns Dec 31 for year granularity" {
    const period = Period{
        .start = Date.initUnchecked(2024, 1, 1),
        .granularity = .year,
    };
    const end_date = period.end();
    try std.testing.expectEqual(Date.initUnchecked(2024, 12, 31), end_date);
}
```

**Step 6: Implement Period.end() method**

Update `Period` struct in `src/parse.zig`:

```zig
pub const Period = struct {
    start: Date,
    granularity: Granularity,

    /// Compute the last day of this period
    pub fn end(self: Period) Date {
        return switch (self.granularity) {
            .day => self.start,
            .week => addDaysInternal(self.start, 6),
            .month => DateMod.Date.initUnchecked(
                self.start.year,
                self.start.month,
                DateMod.daysInMonth(self.start.year, self.start.month),
            ),
            .year => DateMod.Date.initUnchecked(self.start.year, 12, 31),
        };
    }
};
```

**Step 7: Run tests**

Run: `zig build test`
Expected: All tests pass including 4 new Period.end() tests

**Step 8: Commit**

```bash
git add src/parse.zig
git commit -m "feat: implement Period.end() for all granularities"
```

---

### Task 3: Add arithmetic helpers

**Files:**
- Modify: `src/arithmetic.zig`
- Modify: `src/root.zig`

**Step 1: Write failing test for firstDayOfMonth**

Add to `src/arithmetic.zig`:

```zig
test "firstDayOfMonth returns 1st of month" {
    const date = Date.initUnchecked(2024, 6, 15);
    const first = firstDayOfMonth(date);
    try std.testing.expectEqual(Date.initUnchecked(2024, 6, 1), first);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL - 'firstDayOfMonth' not declared

**Step 3: Implement firstDayOfMonth**

```zig
/// Get the first day of the month containing this date.
pub fn firstDayOfMonth(date: Date) Date {
    return Date.initUnchecked(date.year, date.month, 1);
}
```

**Step 4: Write failing test for lastDayOfMonth**

```zig
test "lastDayOfMonth returns last day" {
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 2, 29),
        lastDayOfMonth(Date.initUnchecked(2024, 2, 15)),
    );
    try std.testing.expectEqual(
        Date.initUnchecked(2023, 2, 28),
        lastDayOfMonth(Date.initUnchecked(2023, 2, 15)),
    );
}
```

**Step 5: Implement lastDayOfMonth**

```zig
/// Get the last day of the month containing this date.
pub fn lastDayOfMonth(date: Date) Date {
    return Date.initUnchecked(date.year, date.month, daysInMonth(date.year, date.month));
}
```

**Step 6: Write failing test for startOfWeek**

```zig
test "startOfWeek returns Monday" {
    // Wednesday Jan 17, 2024 -> Monday Jan 15, 2024
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 1, 15),
        startOfWeek(Date.initUnchecked(2024, 1, 17)),
    );
    // Monday stays Monday
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 1, 15),
        startOfWeek(Date.initUnchecked(2024, 1, 15)),
    );
    // Sunday Jan 21 -> Monday Jan 15
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 1, 15),
        startOfWeek(Date.initUnchecked(2024, 1, 21)),
    );
}
```

**Step 7: Implement startOfWeek**

First, add dayOfWeek helper (copy from parse.zig or make public):

```zig
/// Get day of week (0=Monday, 6=Sunday).
pub fn dayOfWeek(date: Date) u8 {
    return @intCast(@mod(dateToEpochDays(date) + 3, 7));
}

/// Get the Monday of the week containing this date.
pub fn startOfWeek(date: Date) Date {
    const dow = dayOfWeek(date);
    return addDays(date, -@as(i32, dow));
}
```

**Step 8: Write failing test for endOfWeek**

```zig
test "endOfWeek returns Sunday" {
    // Wednesday Jan 17, 2024 -> Sunday Jan 21, 2024
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 1, 21),
        endOfWeek(Date.initUnchecked(2024, 1, 17)),
    );
    // Sunday stays Sunday
    try std.testing.expectEqual(
        Date.initUnchecked(2024, 1, 21),
        endOfWeek(Date.initUnchecked(2024, 1, 21)),
    );
}
```

**Step 9: Implement endOfWeek**

```zig
/// Get the Sunday of the week containing this date.
pub fn endOfWeek(date: Date) Date {
    const dow = dayOfWeek(date);
    return addDays(date, @as(i32, 6 - dow));
}
```

**Step 10: Write failing test for addYears**

```zig
test "addYears adds years" {
    const date = Date.initUnchecked(2024, 6, 15);
    const result = try addYears(date, 2);
    try std.testing.expectEqual(Date.initUnchecked(2026, 6, 15), result);
}

test "addYears handles leap year edge case" {
    // Feb 29, 2024 + 1 year -> Feb 28, 2025 (clamp)
    const date = Date.initUnchecked(2024, 2, 29);
    const result = try addYears(date, 1);
    try std.testing.expectEqual(Date.initUnchecked(2025, 2, 28), result);
}

test "addYears returns error for year overflow" {
    const date = Date.initUnchecked(65535, 1, 1);
    try std.testing.expectError(error.YearOutOfRange, addYears(date, 1));
}

test "addYears returns error for year underflow" {
    const date = Date.initUnchecked(1, 1, 1);
    try std.testing.expectError(error.YearOutOfRange, addYears(date, -1));
}
```

**Step 11: Implement addYears**

```zig
/// Add (or subtract) years from a date. Day is clamped if Feb 29 in non-leap year.
/// Returns error if result year would be outside valid range (1-65535).
pub fn addYears(date: Date, years: i32) ArithmeticError!Date {
    const new_year_i64: i64 = @as(i64, date.year) + @as(i64, years);

    if (new_year_i64 < 1 or new_year_i64 > 65535) {
        return error.YearOutOfRange;
    }

    const year: u16 = @intCast(new_year_i64);
    const max_day = daysInMonth(year, date.month);
    const day = @min(date.day, max_day);

    return Date.initUnchecked(year, date.month, day);
}
```

**Step 12: Export new functions from root.zig**

Add to `src/root.zig`:

```zig
pub const firstDayOfMonth = @import("arithmetic.zig").firstDayOfMonth;
pub const lastDayOfMonth = @import("arithmetic.zig").lastDayOfMonth;
pub const startOfWeek = @import("arithmetic.zig").startOfWeek;
pub const endOfWeek = @import("arithmetic.zig").endOfWeek;
pub const dayOfWeek = @import("arithmetic.zig").dayOfWeek;
pub const addYears = @import("arithmetic.zig").addYears;
```

**Step 13: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 14: Commit**

```bash
git add src/arithmetic.zig src/root.zig
git commit -m "feat: add arithmetic helpers for week/month/year boundaries"
```

---

### Task 4: Add backward offsets (-Nd, -Nw, -Nm, -Ny)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing test for -3d**

Add to `src/parse.zig`:

```zig
test "parse '-3d' subtracts days" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("-3d", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 12), result.date);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL - InvalidFormat

**Step 3: Write more backward offset tests**

```zig
test "parse '-2w' subtracts weeks" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("-2w", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.date);
}

test "parse '-1m' subtracts months" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("-1m", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), result.date);
}

test "parse '-1y' subtracts years" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("-1y", ref);
    try std.testing.expectEqual(Date.initUnchecked(2023, 6, 15), result.date);
}

test "parse '-0d' returns InvalidOffset" {
    const ref = Date.initUnchecked(2024, 1, 15);
    try std.testing.expectError(error.InvalidOffset, parseWithReference("-0d", ref));
}
```

**Step 4: Update parseOffset to handle negative offsets**

Modify `parseOffset` function in `src/parse.zig`:

```zig
/// Parse offset format: +Nd, +Nw, +Nm, +Ny, -Nd, -Nw, -Nm, -Ny
fn parseOffset(str: []const u8) (ParseError)!Offset {
    if (str.len < 3) return error.InvalidFormat;

    // Must start with + or -
    const sign: i32 = switch (str[0]) {
        '+' => 1,
        '-' => -1,
        else => return error.InvalidFormat,
    };

    // Check for invalid characters after sign (like +-)
    if (str[1] == '-' or str[1] == '+') return error.InvalidFormat;

    // Extract unit from last character
    const unit_char = str[str.len - 1];
    const unit: OffsetUnit = switch (unit_char) {
        'd' => .day,
        'w' => .week,
        'm' => .month,
        'y' => .year,
        else => return error.InvalidFormat,
    };

    // Parse the number between sign and unit
    const num_str = str[1 .. str.len - 1];
    if (num_str.len == 0) return error.InvalidFormat;

    const value = std.fmt.parseInt(u32, num_str, 10) catch return error.InvalidFormat;

    // Zero offset is invalid
    if (value == 0) return error.InvalidOffset;

    return .{ .value = value, .unit = unit, .sign = sign };
}
```

**Step 5: Update Offset struct to include sign**

```zig
const Offset = struct {
    value: u32,
    unit: OffsetUnit,
    sign: i32,
};
```

**Step 6: Add year to OffsetUnit enum**

```zig
const OffsetUnit = enum { day, week, month, year };
```

**Step 7: Update applyOffset to use sign and handle year**

```zig
fn applyOffset(date: Date, offset: Offset) (ArithmeticError)!Date {
    const signed_value: i32 = @as(i32, @intCast(offset.value)) * offset.sign;
    return switch (offset.unit) {
        .day => addDaysInternal(date, signed_value),
        .week => addDaysInternal(date, signed_value * 7),
        .month => arithmetic.addMonths(date, signed_value),
        .year => arithmetic.addYears(date, signed_value),
    };
}
```

**Step 8: Add +Ny tests**

```zig
test "parse '+1y' adds years" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("+1y", ref);
    try std.testing.expectEqual(Date.initUnchecked(2025, 6, 15), result.date);
}

test "parse '+2y' adds years" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("+2y", ref);
    try std.testing.expectEqual(Date.initUnchecked(2026, 6, 15), result.date);
}
```

**Step 9: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 10: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add backward offsets (-Nd, -Nw, -Nm, -Ny) and year offsets (+Ny)"
```

---

### Task 5: Add weekday modifiers (next monday, last friday)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing test for "next monday"**

```zig
test "parse 'next monday' skips to following week" {
    // Reference: Monday Jan 15, 2024
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("next monday", ref);
    // Should skip this week's Monday (today) and go to next Monday
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 22), result.date);
}

test "parse 'next friday' from Monday" {
    const ref = Date.initUnchecked(2024, 1, 15); // Monday
    const result = try parseWithReference("next friday", ref);
    // Next Friday after skipping this week = Jan 26
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 26), result.date);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL - InvalidFormat (multi-word not parsed)

**Step 3: Write tests for "last monday"**

```zig
test "parse 'last monday' returns previous Monday" {
    // Reference: Wednesday Jan 17, 2024
    const ref = Date.initUnchecked(2024, 1, 17);
    const result = try parseWithReference("last monday", ref);
    // Previous Monday is Jan 15
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), result.date);
}

test "parse 'last monday' on Monday returns week before" {
    // Reference: Monday Jan 15, 2024
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("last monday", ref);
    // Previous Monday is Jan 8
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 8), result.date);
}

test "parse 'last friday' from Monday" {
    const ref = Date.initUnchecked(2024, 1, 15); // Monday
    const result = try parseWithReference("last friday", ref);
    // Last Friday is Jan 12
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 12), result.date);
}
```

**Step 4: Implement weekday modifier parsing**

Add new function in `src/parse.zig`:

```zig
/// Parse "next <weekday>" or "last <weekday>"
fn parseWeekdayModifier(str: []const u8, reference: Date) ?Date {
    // Try "next <weekday>"
    if (std.mem.startsWith(u8, str, "next ")) {
        const weekday_str = str[5..];
        if (parseWeekday(weekday_str)) |target_dow| {
            // Get next occurrence, then add 7 days to skip to following week
            const next = nextWeekday(reference, target_dow);
            return addDaysInternal(next, 7);
        }
    }

    // Try "last <weekday>"
    if (std.mem.startsWith(u8, str, "last ")) {
        const weekday_str = str[5..];
        if (parseWeekday(weekday_str)) |target_dow| {
            return lastWeekday(reference, target_dow);
        }
    }

    return null;
}

/// Find most recent past occurrence of target weekday (always in past, 1-7 days back).
fn lastWeekday(from: Date, target_dow: u8) Date {
    const current_dow = dayOfWeek(from);
    var days_back: i32 = @as(i32, current_dow) - @as(i32, target_dow);
    if (days_back <= 0) {
        days_back += 7;
    }
    return addDaysInternal(from, -days_back);
}
```

**Step 5: Add call to parseWeekdayModifier in parseWithReference**

Add after clear keywords check and before other parsers:

```zig
    // Weekday with modifier: "next monday", "last friday"
    if (parseWeekdayModifier(lower, reference)) |date| {
        return .{ .date = date };
    }
```

**Step 6: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add weekday modifiers (next monday, last friday)"
```

---

### Task 6: Add period references (next week, last month, this year, etc.)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests for period references**

```zig
test "parse 'next week' returns period" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("next week", ref);
    // Should return Monday of next week
    try std.testing.expectEqual(Granularity.week, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 22), result.period.start);
}

test "parse 'last week' returns period" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("last week", ref);
    try std.testing.expectEqual(Granularity.week, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 8), result.period.start);
}

test "parse 'this week' returns period" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("this week", ref);
    try std.testing.expectEqual(Granularity.week, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), result.period.start);
}

test "parse 'next month' returns period" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("next month", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 1), result.period.start);
}

test "parse 'last month' returns period" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("last month", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.period.start);
}

test "parse 'this month' returns period" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("this month", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.period.start);
}

test "parse 'next year' returns period" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("next year", ref);
    try std.testing.expectEqual(Granularity.year, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2025, 1, 1), result.period.start);
}

test "parse 'last year' returns period" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("last year", ref);
    try std.testing.expectEqual(Granularity.year, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2023, 1, 1), result.period.start);
}

test "parse 'this year' returns period" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("this year", ref);
    try std.testing.expectEqual(Granularity.year, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.period.start);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL

**Step 3: Implement parsePeriodReference function**

```zig
/// Parse period references: "next week", "last month", "this year", etc.
fn parsePeriodReference(str: []const u8, reference: Date) ?ParsedDate {
    // Week references
    if (std.mem.eql(u8, str, "next week")) {
        const this_monday = arithmetic.startOfWeek(reference);
        const next_monday = addDaysInternal(this_monday, 7);
        return .{ .period = .{ .start = next_monday, .granularity = .week } };
    }
    if (std.mem.eql(u8, str, "last week")) {
        const this_monday = arithmetic.startOfWeek(reference);
        const last_monday = addDaysInternal(this_monday, -7);
        return .{ .period = .{ .start = last_monday, .granularity = .week } };
    }
    if (std.mem.eql(u8, str, "this week")) {
        const this_monday = arithmetic.startOfWeek(reference);
        return .{ .period = .{ .start = this_monday, .granularity = .week } };
    }

    // Month references
    if (std.mem.eql(u8, str, "next month")) {
        const next = arithmetic.addMonths(reference, 1) catch return null;
        return .{ .period = .{ .start = arithmetic.firstDayOfMonth(next), .granularity = .month } };
    }
    if (std.mem.eql(u8, str, "last month")) {
        const prev = arithmetic.addMonths(reference, -1) catch return null;
        return .{ .period = .{ .start = arithmetic.firstDayOfMonth(prev), .granularity = .month } };
    }
    if (std.mem.eql(u8, str, "this month")) {
        return .{ .period = .{ .start = arithmetic.firstDayOfMonth(reference), .granularity = .month } };
    }

    // Year references
    if (std.mem.eql(u8, str, "next year")) {
        const next = arithmetic.addYears(reference, 1) catch return null;
        return .{ .period = .{ .start = Date.initUnchecked(next.year, 1, 1), .granularity = .year } };
    }
    if (std.mem.eql(u8, str, "last year")) {
        const prev = arithmetic.addYears(reference, -1) catch return null;
        return .{ .period = .{ .start = Date.initUnchecked(prev.year, 1, 1), .granularity = .year } };
    }
    if (std.mem.eql(u8, str, "this year")) {
        return .{ .period = .{ .start = Date.initUnchecked(reference.year, 1, 1), .granularity = .year } };
    }

    return null;
}
```

**Step 4: Add imports at top of parse.zig**

Make sure arithmetic functions are available:

```zig
const arithmetic = @import("arithmetic.zig");
```

**Step 5: Add call to parsePeriodReference in parseWithReference**

Add after weekday modifier check:

```zig
    // Period references: "next week", "last month", "this year"
    if (parsePeriodReference(lower, reference)) |parsed| {
        return parsed;
    }
```

**Step 6: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add period references (next/last/this week/month/year)"
```

---

### Task 7: Add natural offsets (in 3 days, 2 weeks ago)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests**

```zig
test "parse 'in 3 days'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("in 3 days", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 18), result.date);
}

test "parse 'in 2 weeks'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("in 2 weeks", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 29), result.date);
}

test "parse 'in 1 month'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("in 1 month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 15), result.date);
}

test "parse 'in 1 year'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("in 1 year", ref);
    try std.testing.expectEqual(Date.initUnchecked(2025, 1, 15), result.date);
}

test "parse '3 days ago'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("3 days ago", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 12), result.date);
}

test "parse '2 weeks ago'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("2 weeks ago", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.date);
}

test "parse '1 month ago'" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("1 month ago", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), result.date);
}

test "parse '1 year ago'" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("1 year ago", ref);
    try std.testing.expectEqual(Date.initUnchecked(2023, 6, 15), result.date);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL

**Step 3: Implement parseNaturalOffset function**

```zig
/// Parse natural offset: "in 3 days", "2 weeks ago", etc.
fn parseNaturalOffset(str: []const u8, reference: Date) ?ParsedDate {
    // Try "in N <unit>" pattern
    if (std.mem.startsWith(u8, str, "in ")) {
        const rest = str[3..];
        if (parseNaturalOffsetValue(rest, 1, reference)) |date| {
            return .{ .date = date };
        }
    }

    // Try "N <unit> ago" pattern
    if (std.mem.endsWith(u8, str, " ago")) {
        const rest = str[0 .. str.len - 4];
        if (parseNaturalOffsetValue(rest, -1, reference)) |date| {
            return .{ .date = date };
        }
    }

    return null;
}

/// Parse "N <unit>" and apply with given sign multiplier
fn parseNaturalOffsetValue(str: []const u8, sign: i32, reference: Date) ?Date {
    // Find the space separating number and unit
    const space_idx = std.mem.indexOf(u8, str, " ") orelse return null;

    const num_str = str[0..space_idx];
    const unit_str = str[space_idx + 1 ..];

    const value = std.fmt.parseInt(u32, num_str, 10) catch return null;
    if (value == 0) return null;

    const signed_value: i32 = @as(i32, @intCast(value)) * sign;

    // Match unit (singular or plural)
    if (std.mem.eql(u8, unit_str, "day") or std.mem.eql(u8, unit_str, "days")) {
        return addDaysInternal(reference, signed_value);
    }
    if (std.mem.eql(u8, unit_str, "week") or std.mem.eql(u8, unit_str, "weeks")) {
        return addDaysInternal(reference, signed_value * 7);
    }
    if (std.mem.eql(u8, unit_str, "month") or std.mem.eql(u8, unit_str, "months")) {
        return arithmetic.addMonths(reference, signed_value) catch return null;
    }
    if (std.mem.eql(u8, unit_str, "year") or std.mem.eql(u8, unit_str, "years")) {
        return arithmetic.addYears(reference, signed_value) catch return null;
    }

    return null;
}
```

**Step 4: Add call in parseWithReference**

Add after period references:

```zig
    // Natural offsets: "in 3 days", "2 weeks ago"
    if (parseNaturalOffset(lower, reference)) |parsed| {
        return parsed;
    }
```

**Step 5: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add natural offsets (in N days, N weeks ago)"
```

---

### Task 8: Add boundary expressions (end of month, beginning of week)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests for current period boundaries**

```zig
test "parse 'end of month'" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("end of month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 29), result.date);
}

test "parse 'beginning of month'" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("beginning of month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 1), result.date);
}

test "parse 'end of week'" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("end of week", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 21), result.date); // Sunday
}

test "parse 'beginning of week'" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("beginning of week", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 15), result.date); // Monday
}

test "parse 'end of year'" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("end of year", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 12, 31), result.date);
}

test "parse 'beginning of year'" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("beginning of year", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.date);
}
```

**Step 2: Write tests for modified period boundaries**

```zig
test "parse 'end of next month'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("end of next month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 29), result.date);
}

test "parse 'beginning of next month'" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("beginning of next month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 1), result.date);
}

test "parse 'end of last month'" {
    const ref = Date.initUnchecked(2024, 2, 15);
    const result = try parseWithReference("end of last month", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 31), result.date);
}

test "parse 'end of next week'" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("end of next week", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 28), result.date); // Sunday of next week
}

test "parse 'beginning of next week'" {
    const ref = Date.initUnchecked(2024, 1, 17); // Wednesday
    const result = try parseWithReference("beginning of next week", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 22), result.date); // Monday of next week
}
```

**Step 3: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL

**Step 4: Implement parseBoundaryExpression function**

```zig
/// Parse boundary expressions: "end of month", "beginning of next week", etc.
fn parseBoundaryExpression(str: []const u8, reference: Date) ?Date {
    // Current period boundaries
    if (std.mem.eql(u8, str, "end of month")) {
        return arithmetic.lastDayOfMonth(reference);
    }
    if (std.mem.eql(u8, str, "beginning of month")) {
        return arithmetic.firstDayOfMonth(reference);
    }
    if (std.mem.eql(u8, str, "end of week")) {
        return arithmetic.endOfWeek(reference);
    }
    if (std.mem.eql(u8, str, "beginning of week")) {
        return arithmetic.startOfWeek(reference);
    }
    if (std.mem.eql(u8, str, "end of year")) {
        return Date.initUnchecked(reference.year, 12, 31);
    }
    if (std.mem.eql(u8, str, "beginning of year")) {
        return Date.initUnchecked(reference.year, 1, 1);
    }

    // Next period boundaries
    if (std.mem.eql(u8, str, "end of next month")) {
        const next = arithmetic.addMonths(reference, 1) catch return null;
        return arithmetic.lastDayOfMonth(next);
    }
    if (std.mem.eql(u8, str, "beginning of next month")) {
        const next = arithmetic.addMonths(reference, 1) catch return null;
        return arithmetic.firstDayOfMonth(next);
    }
    if (std.mem.eql(u8, str, "end of next week")) {
        const next_monday = addDaysInternal(arithmetic.startOfWeek(reference), 7);
        return arithmetic.endOfWeek(next_monday);
    }
    if (std.mem.eql(u8, str, "beginning of next week")) {
        return addDaysInternal(arithmetic.startOfWeek(reference), 7);
    }
    if (std.mem.eql(u8, str, "end of next year")) {
        const next = arithmetic.addYears(reference, 1) catch return null;
        return Date.initUnchecked(next.year, 12, 31);
    }
    if (std.mem.eql(u8, str, "beginning of next year")) {
        const next = arithmetic.addYears(reference, 1) catch return null;
        return Date.initUnchecked(next.year, 1, 1);
    }

    // Last period boundaries
    if (std.mem.eql(u8, str, "end of last month")) {
        const prev = arithmetic.addMonths(reference, -1) catch return null;
        return arithmetic.lastDayOfMonth(prev);
    }
    if (std.mem.eql(u8, str, "beginning of last month")) {
        const prev = arithmetic.addMonths(reference, -1) catch return null;
        return arithmetic.firstDayOfMonth(prev);
    }
    if (std.mem.eql(u8, str, "end of last week")) {
        const last_monday = addDaysInternal(arithmetic.startOfWeek(reference), -7);
        return arithmetic.endOfWeek(last_monday);
    }
    if (std.mem.eql(u8, str, "beginning of last week")) {
        return addDaysInternal(arithmetic.startOfWeek(reference), -7);
    }
    if (std.mem.eql(u8, str, "end of last year")) {
        const prev = arithmetic.addYears(reference, -1) catch return null;
        return Date.initUnchecked(prev.year, 12, 31);
    }
    if (std.mem.eql(u8, str, "beginning of last year")) {
        const prev = arithmetic.addYears(reference, -1) catch return null;
        return Date.initUnchecked(prev.year, 1, 1);
    }

    return null;
}
```

**Step 5: Add call in parseWithReference - EARLY (before other parsers)**

Add after clear keywords, BEFORE weekday modifiers:

```zig
    // Boundary expressions (most specific multi-word)
    if (parseBoundaryExpression(lower, reference)) |date| {
        return .{ .date = date };
    }
```

**Step 6: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add boundary expressions (end of month, beginning of week, etc.)"
```

---

### Task 9: Add month names as periods

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests**

```zig
test "parse 'february' in January returns this year" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("february", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 2, 1), result.period.start);
}

test "parse 'february' in March returns next year" {
    const ref = Date.initUnchecked(2024, 3, 15);
    const result = try parseWithReference("february", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2025, 2, 1), result.period.start);
}

test "parse 'january' in January returns next year" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("january", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2025, 1, 1), result.period.start);
}

test "parse 'dec' abbreviation works" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const result = try parseWithReference("dec", ref);
    try std.testing.expectEqual(Granularity.month, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 12, 1), result.period.start);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL (currently parses weekdays, not months)

**Step 3: Implement parseMonthName function**

```zig
/// Parse month name and return as period.
fn parseMonthName(str: []const u8, reference: Date) ?ParsedDate {
    const months = [_]struct { full: []const u8, abbrev: []const u8, month: u8 }{
        .{ .full = "january", .abbrev = "jan", .month = 1 },
        .{ .full = "february", .abbrev = "feb", .month = 2 },
        .{ .full = "march", .abbrev = "mar", .month = 3 },
        .{ .full = "april", .abbrev = "apr", .month = 4 },
        .{ .full = "may", .abbrev = "may", .month = 5 },
        .{ .full = "june", .abbrev = "jun", .month = 6 },
        .{ .full = "july", .abbrev = "jul", .month = 7 },
        .{ .full = "august", .abbrev = "aug", .month = 8 },
        .{ .full = "september", .abbrev = "sep", .month = 9 },
        .{ .full = "october", .abbrev = "oct", .month = 10 },
        .{ .full = "november", .abbrev = "nov", .month = 11 },
        .{ .full = "december", .abbrev = "dec", .month = 12 },
    };

    for (months) |m| {
        if (std.mem.eql(u8, str, m.full) or std.mem.eql(u8, str, m.abbrev)) {
            // If target month is current or past, use next year
            const year: u16 = if (m.month <= reference.month) reference.year + 1 else reference.year;
            return .{ .period = .{
                .start = Date.initUnchecked(year, m.month, 1),
                .granularity = .month,
            } };
        }
    }

    return null;
}
```

**Step 4: Add call in parseWithReference - AFTER weekday names**

Add after simple keywords and weekday names:

```zig
    // Month names as periods
    if (parseMonthName(lower, reference)) |parsed| {
        return parsed;
    }
```

**Step 5: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add month names as periods (february, dec)"
```

---

### Task 10: Add ordinal days (1st, 23rd)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests**

```zig
test "parse '1st' returns 1st of current month" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("1st", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 6, 1), result.date);
}

test "parse '23rd' returns 23rd of current month" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("23rd", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 6, 23), result.date);
}

test "parse '2nd' returns 2nd of current month" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("2nd", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 6, 2), result.date);
}

test "parse '31st' in short month returns error" {
    const ref = Date.initUnchecked(2024, 6, 15); // June has 30 days
    try std.testing.expectError(error.InvalidDay, parseWithReference("31st", ref));
}

test "parse '11th' works" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("11th", ref);
    try std.testing.expectEqual(Date.initUnchecked(2024, 6, 11), result.date);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL

**Step 3: Implement parseOrdinalDay function**

```zig
/// Parse ordinal day: "1st", "2nd", "3rd", "4th", "23rd", etc.
fn parseOrdinalDay(str: []const u8, reference: Date) (ParseError || DateError)!?Date {
    // Must end with st, nd, rd, or th
    if (str.len < 3) return null;

    const suffix = str[str.len - 2 ..];
    const valid_suffix = std.mem.eql(u8, suffix, "st") or
        std.mem.eql(u8, suffix, "nd") or
        std.mem.eql(u8, suffix, "rd") or
        std.mem.eql(u8, suffix, "th");
    if (!valid_suffix) return null;

    const num_str = str[0 .. str.len - 2];
    const day = std.fmt.parseInt(u8, num_str, 10) catch return null;

    // Validate day for current month
    return try Date.init(reference.year, reference.month, day);
}
```

**Step 4: Add call in parseWithReference - AFTER offsets, BEFORE absolute dates**

```zig
    // Ordinal days: "1st", "23rd"
    if (try parseOrdinalDay(lower, reference)) |date| {
        return .{ .date = date };
    }
```

**Step 5: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add ordinal day parsing (1st, 2nd, 23rd)"
```

---

### Task 11: Add bare year as period (2024)

**Files:**
- Modify: `src/parse.zig`

**Step 1: Write failing tests**

```zig
test "parse '2024' as year period" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("2024", ref);
    try std.testing.expectEqual(Granularity.year, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2024, 1, 1), result.period.start);
}

test "parse '2025' as year period" {
    const ref = Date.initUnchecked(2024, 6, 15);
    const result = try parseWithReference("2025", ref);
    try std.testing.expectEqual(Granularity.year, result.period.granularity);
    try std.testing.expectEqual(Date.initUnchecked(2025, 1, 1), result.period.start);
}
```

**Step 2: Run test to verify it fails**

Run: `zig build test`
Expected: FAIL (currently "2024" is InvalidFormat or might parse as day)

**Step 3: Update parseAbsoluteDate to handle bare year**

Modify `parseAbsoluteDate` in `src/parse.zig` to return `ParsedDate` instead of `Date`:

First, change function signature and update YYYY-MM-DD and MM-DD cases:

```zig
/// Parse absolute date formats: YYYY-MM-DD, MM-DD, DD, YYYY
fn parseAbsoluteDate(str: []const u8, reference: Date) (ParseError || DateError)!ParsedDate {
    // Check for YYYY-MM-DD format (length 10, dashes at positions 4 and 7)
    if (str.len == 10 and str[4] == '-' and str[7] == '-') {
        const year = std.fmt.parseInt(u16, str[0..4], 10) catch return error.InvalidFormat;
        const month = std.fmt.parseInt(u8, str[5..7], 10) catch return error.InvalidFormat;
        const day = std.fmt.parseInt(u8, str[8..10], 10) catch return error.InvalidFormat;
        return .{ .date = try Date.init(year, month, day) };
    }

    // Check for MM-DD format (length 5, dash at position 2)
    if (str.len == 5 and str[2] == '-') {
        const month = std.fmt.parseInt(u8, str[0..2], 10) catch return error.InvalidFormat;
        const day = std.fmt.parseInt(u8, str[3..5], 10) catch return error.InvalidFormat;
        return .{ .date = try Date.init(reference.year, month, day) };
    }

    // Check for YYYY format (4 digits, all numeric) - returns period
    if (str.len == 4) {
        var all_digits = true;
        for (str) |c| {
            if (!std.ascii.isDigit(c)) {
                all_digits = false;
                break;
            }
        }
        if (all_digits) {
            const year = std.fmt.parseInt(u16, str, 10) catch return error.InvalidFormat;
            if (year == 0) return error.InvalidYear;
            return .{ .period = .{
                .start = Date.initUnchecked(year, 1, 1),
                .granularity = .year,
            } };
        }
    }

    // Check for DD format (length 1-2, all digits)
    if (str.len >= 1 and str.len <= 2) {
        for (str) |c| {
            if (!std.ascii.isDigit(c)) return error.InvalidFormat;
        }
        const day = std.fmt.parseInt(u8, str, 10) catch return error.InvalidFormat;
        return .{ .date = try Date.init(reference.year, reference.month, day) };
    }

    return error.InvalidFormat;
}
```

**Step 4: Update caller in parseWithReference**

Change:
```zig
    if (parseAbsoluteDate(trimmed, reference)) |date| {
        return .{ .date = date };
    } else |err| {
        return err;
    }
```

To:
```zig
    return parseAbsoluteDate(trimmed, reference);
```

**Step 5: Run all tests**

Run: `zig build test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add src/parse.zig
git commit -m "feat: add bare year parsing as period (2024)"
```

---

### Task 12: Update format.zig for period support

**Files:**
- Modify: `src/format.zig`

**Step 1: Write failing test for period formatting**

```zig
test "formatRelative handles period start" {
    const ref = Date.initUnchecked(2024, 1, 15);
    const period_start = Date.initUnchecked(2024, 2, 1);
    var buf: [max_format_len]u8 = undefined;
    const result = formatRelative(period_start, ref, &buf);
    // Feb 1 is 17 days away, should show "Feb 1"
    try std.testing.expectEqualStrings("Feb 1", result);
}
```

**Step 2: Run tests to verify formatting still works**

Run: `zig build test`
Expected: Pass (no changes needed, periods use their .start date)

**Step 3: Commit (no changes needed)**

No commit needed - formatting already works with period.start.

---

### Task 13: Update root.zig exports and run final tests

**Files:**
- Modify: `src/root.zig`

**Step 1: Verify all new types are exported**

Ensure `src/root.zig` has:

```zig
pub const Granularity = @import("parse.zig").Granularity;
pub const Period = @import("parse.zig").Period;
```

And arithmetic exports:
```zig
pub const firstDayOfMonth = @import("arithmetic.zig").firstDayOfMonth;
pub const lastDayOfMonth = @import("arithmetic.zig").lastDayOfMonth;
pub const startOfWeek = @import("arithmetic.zig").startOfWeek;
pub const endOfWeek = @import("arithmetic.zig").endOfWeek;
pub const dayOfWeek = @import("arithmetic.zig").dayOfWeek;
pub const addYears = @import("arithmetic.zig").addYears;
```

**Step 2: Run full test suite**

Run: `zig build test`
Expected: All ~130 tests pass

**Step 3: Commit**

```bash
git add src/root.zig
git commit -m "feat: finalize v0.2.0 exports"
```

---

### Task 14: Update README and bump version

**Files:**
- Modify: `README.md`
- Modify: `build.zig.zon`

**Step 1: Update README with new features**

Add new sections to README.md documenting:
- Period return type
- Backward offsets
- Weekday modifiers
- Natural offsets
- Boundary expressions
- Month names
- Ordinal days

**Step 2: Update version in build.zig.zon**

Change `.version = "0.0.0"` to `.version = "0.2.0"`

**Step 3: Run final tests**

Run: `zig build test`
Expected: All tests pass

**Step 4: Commit**

```bash
git add README.md build.zig.zon
git commit -m "docs: update README for v0.2.0, bump version"
```

**Step 5: Push**

```bash
git push origin main
```

---

## Summary

**Total tasks:** 14
**Estimated tests:** ~130 (up from 53)
**New types:** `Granularity`, `Period`
**New ParsedDate variant:** `.period`

**Breaking changes:**
- `ParsedDate` union gains `.period` â€” existing switch statements need updating
- `parseAbsoluteDate` internal function now returns `ParsedDate`

**Test reference date:** 2024-01-15 (Monday) for consistent week boundary testing
